---
title: Quantizing Deltas
sidebar_position: 2
---

# Quantizing Deltas

Reduce network noise by normalizing (quantizing) your outgoing updates before they’re sent. This tutorial shows how to round positions and strip jitter using the normalization hook (aka "normalizeDelta").

## Why quantize?

- Smooths tiny fluctuations in values like `x`/`y`
- Lowers bandwidth by avoiding unnecessary updates
- Makes deltas more deterministic across clients

## Quick start

```js
import { Lab13Client } from 'https://esm.sh/js13k'

// Quantization function
function quantizeDelta(delta) {
  return {
    ...delta,
    _players: Object.fromEntries(
      Object.entries(delta._players || {}).map(([id, p]) => [
        id,
        p == null ? null : { ...p, x: Math.round(p.x || 0), y: Math.round(p.y || 0) },
      ])
    ),
  }
}

// Use before sending updates
function updatePlayerPosition(x, y) {
  const delta = {
    _players: {
      [client.playerId()]: { x, y },
    },
  }

  const quantized = quantizeDelta(delta)
  client.mutateState(quantized)
}
```

## Explanation

- The hook receives the pending changes and returns a normalized copy.
- Here we round `x` and `y` to the nearest pixel so tiny sub‑pixel movements don’t trigger new network messages.
- `null` values are preserved so deletions still propagate.
- You can also filter out local-only fields so they don't get mirrored. In the Cats demo, we exclude `mouse.vx` and `mouse.vy` from outgoing deltas because velocity is simulated locally.

## Practical tips

- Quantize only the fields that change frequently.
- For analog inputs, consider snapping to a grid (e.g., every 2–4 pixels).
- Combine with a `deltaEvaluator` to skip low‑value updates entirely.

```js
// Advanced quantization with grid snapping
function quantizeDelta(delta) {
  return {
    ...delta,
    _players: Object.fromEntries(
      Object.entries(delta._players || {}).map(([id, p]) => [
        id,
        p == null
          ? null
          : {
              ...p,
              x: Math.round((p.x || 0) / 2) * 2, // snap to even pixels
              y: Math.round((p.y || 0) / 2) * 2,
            },
      ])
    ),
  }
}

// Combine with delta evaluation
function updatePlayerPosition(x, y) {
  const delta = {
    _players: {
      [client.playerId()]: { x, y },
    },
  }

  const quantized = quantizeDelta(delta)
  const currentState = client.state()
  const myId = client.playerId()

  // Check if position actually changed
  const dx = quantized._players[myId]?.x
  const dy = quantized._players[myId]?.y
  if (dx == null && dy == null) return

  const prev = currentState._players?.[myId] || {}
  const hasChanged = Math.abs((dx ?? prev.x) - (prev.x || 0)) > 0 || Math.abs((dy ?? prev.y) - (prev.y || 0)) > 0

  if (hasChanged) {
    client.mutateState(quantized)
  }
}
```
