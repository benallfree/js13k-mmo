<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Flight Simulator: JS13K MMO Challenge Series</title>
    <meta name="title" content="Flight Simulator: JS13K MMO Challenge Series" />
    <meta name="description" content="Flight Simulator: JS13K MMO Challenge Series" />
    <meta name="author" content="benallfree" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      .status-indicator {
        position: fixed;
        top: 10px;
        right: 10px;
        padding: 8px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        color: white;
        transition: background-color 0.3s ease;
      }
      .status-connecting {
        background-color: #f39c12;
      }
      .status-connected {
        background-color: #27ae60;
      }
      .status-disconnected {
        background-color: #e74c3c;
      }
      .controls {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 8px;
        font-size: 12px;
        max-width: 200px;
      }
      .hud {
        position: fixed;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 8px;
        font-size: 12px;
        font-family: monospace;
      }
    </style>
    <script type="module">
      import * as THREE from 'https://esm.sh/three'
      import Js13kClient from '/sdk.js'

      // Create status indicator
      const statusIndicator = document.createElement('div')
      statusIndicator.className = 'status-indicator status-connecting'
      statusIndicator.textContent = 'Connecting...'
      document.body.appendChild(statusIndicator)

      // Create client
      const client = new Js13kClient('flight')

      // Game state
      let keys = {}

      // Three.js setup
      const scene = new THREE.Scene()
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000)
      const renderer = new THREE.WebGLRenderer({ antialias: false })
      renderer.setSize(window.innerWidth, window.innerHeight)
      renderer.setClearColor(0x87ceeb)
      document.body.appendChild(renderer.domElement)

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6)
      scene.add(ambientLight)
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
      directionalLight.position.set(100, 100, 50)
      scene.add(directionalLight)

      // Ground
      const groundGeometry = new THREE.PlaneGeometry(5000, 5000)
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90ee90 })
      const ground = new THREE.Mesh(groundGeometry, groundMaterial)
      ground.rotation.x = -Math.PI / 2
      scene.add(ground)

      // Add landmarks
      function createLandmarks() {
        // Runway
        const runwayGeometry = new THREE.PlaneGeometry(200, 20)
        const runwayMaterial = new THREE.MeshLambertMaterial({
          color: 0x333333,
        })
        const runway = new THREE.Mesh(runwayGeometry, runwayMaterial)
        runway.rotation.x = -Math.PI / 2
        runway.position.set(0, 0.1, 0)
        scene.add(runway)

        // Runway markings
        for (let i = -8; i <= 8; i += 2) {
          const markingGeometry = new THREE.PlaneGeometry(2, 15)
          const markingMaterial = new THREE.MeshLambertMaterial({
            color: 0xffffff,
          })
          const marking = new THREE.Mesh(markingGeometry, markingMaterial)
          marking.rotation.x = -Math.PI / 2
          marking.position.set(i * 10, 0.2, 0)
          scene.add(marking)
        }

        // Control tower
        const towerGeometry = new THREE.CylinderGeometry(5, 8, 30, 8)
        const towerMaterial = new THREE.MeshLambertMaterial({
          color: 0x666666,
        })
        const tower = new THREE.Mesh(towerGeometry, towerMaterial)
        tower.position.set(50, 15, 50)
        scene.add(tower)

        // Tower top
        const topGeometry = new THREE.BoxGeometry(12, 4, 12)
        const topMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 })
        const top = new THREE.Mesh(topGeometry, topMaterial)
        top.position.set(50, 32, 50)
        scene.add(top)

        // Mountains in the distance
        for (let i = 0; i < 5; i++) {
          const mountainGeometry = new THREE.ConeGeometry(100 + Math.random() * 50, 200 + Math.random() * 100, 6)
          const mountainMaterial = new THREE.MeshLambertMaterial({
            color: 0x8b4513,
          })
          const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial)
          mountain.position.set((Math.random() - 0.5) * 2000, 100 + Math.random() * 100, (Math.random() - 0.5) * 2000)
          scene.add(mountain)
        }

        // Wind turbines
        for (let i = 0; i < 8; i++) {
          const baseGeometry = new THREE.CylinderGeometry(2, 3, 20, 8)
          const baseMaterial = new THREE.MeshLambertMaterial({
            color: 0x888888,
          })
          const base = new THREE.Mesh(baseGeometry, baseMaterial)
          base.position.set((Math.random() - 0.5) * 1000, 10, (Math.random() - 0.5) * 1000)
          scene.add(base)

          // Turbine blades
          const bladeGeometry = new THREE.BoxGeometry(40, 2, 4)
          const bladeMaterial = new THREE.MeshLambertMaterial({
            color: 0xcccccc,
          })
          for (let j = 0; j < 3; j++) {
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial)
            blade.position.copy(base.position)
            blade.position.y += 20
            blade.rotation.y = (j * Math.PI * 2) / 3
            scene.add(blade)
          }
        }

        // Water tower
        const waterTowerGeometry = new THREE.CylinderGeometry(8, 8, 25, 8)
        const waterTowerMaterial = new THREE.MeshLambertMaterial({
          color: 0x87ceeb,
        })
        const waterTower = new THREE.Mesh(waterTowerGeometry, waterTowerMaterial)
        waterTower.position.set(-100, 12.5, -100)
        scene.add(waterTower)

        // Water tower top
        const waterTopGeometry = new THREE.SphereGeometry(10, 8, 6)
        const waterTopMaterial = new THREE.MeshLambertMaterial({
          color: 0x87ceeb,
        })
        const waterTop = new THREE.Mesh(waterTopGeometry, waterTopMaterial)
        waterTop.position.set(-100, 35, -100)
        scene.add(waterTop)
      }

      createLandmarks()

      // Aircraft colors
      const aircraftColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffa500, 0x800080]

      // Create aircraft mesh
      function createAircraft(color = 0xff0000) {
        const group = new THREE.Group()
        group.rotation.z = -Math.PI / 2

        // Fuselage
        const fuselageGeometry = new THREE.CylinderGeometry(1, 2, 8, 8)
        const fuselageMaterial = new THREE.MeshLambertMaterial({ color })
        const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial)
        fuselage.rotation.x = Math.PI / 2
        group.add(fuselage)

        // Wings
        const wingGeometry = new THREE.BoxGeometry(12, 0.5, 3)
        const wingMaterial = new THREE.MeshLambertMaterial({ color })
        const wings = new THREE.Mesh(wingGeometry, wingMaterial)
        wings.rotation.z = Math.PI / 2
        group.add(wings)

        // Tail
        const tailGeometry = new THREE.BoxGeometry(0.5, 4, 2)
        const tailMaterial = new THREE.MeshLambertMaterial({ color })
        const tail = new THREE.Mesh(tailGeometry, tailMaterial)
        tail.position.set(-3, 0, 0)
        tail.rotation.z = Math.PI / 2
        group.add(tail)

        return group
      }

      // Aircraft instances
      const aircrafts = {}

      // HUD elements
      const hudElement = document.querySelector('.hud')

      function updateHUD() {
        const myState = client.getMyState()
        if (!myState) return
        hudElement.innerHTML = `
          ALT: ${Math.max(0, Math.round(myState.y))}m<br>
          SPD: ${Math.round(myState.s || 0)}<br>
          HDG: ${Math.round(((myState.ry * 180) / Math.PI + 360) % 360)}°<br>
          PITCH: ${Math.round((myState.rx * 180) / Math.PI)}°<br>
          ROLL: ${Math.round((myState.rz * 180) / Math.PI)}°
        `
      }

      // Input handling
      document.addEventListener('keydown', (e) => {
        keys[e.code] = true
      })
      document.addEventListener('keyup', (e) => {
        keys[e.code] = false
      })

      // Aircraft physics
      function updateMyAircraft() {
        const myState = client.getMyState(true) // get a deep copy of the state
        if (!myState) return

        let moved = false
        const maxSpeed = 200
        const acceleration = 2
        const drag = 0.98

        // Thrust
        if (keys.KeyW || keys.ArrowUp) {
          myState.s = Math.min(maxSpeed, myState.s + acceleration)
          moved = true
        }
        if (keys.KeyS || keys.ArrowDown) {
          myState.s = Math.max(0, myState.s - acceleration)
          moved = true
        }

        // Controls
        if (keys.KeyA || keys.ArrowLeft) {
          myState.ry += 0.02
          myState.rz = Math.max(-Math.PI / 2 - 0.3, myState.rz - 0.02)
          moved = true
        } else if (keys.KeyD || keys.ArrowRight) {
          myState.ry -= 0.02
          myState.rz = Math.min(-Math.PI / 2 + 0.3, myState.rz + 0.02)
          moved = true
        } else {
          myState.rz += (-Math.PI / 2 - myState.rz) * 0.05
        }

        if (keys.KeyQ) {
          myState.rx = Math.min(0.3, myState.rx + 0.02)
          moved = true
        } else if (keys.KeyE) {
          myState.rx = Math.max(-0.3, myState.rx - 0.02)
          moved = true
        } else {
          myState.rx *= 0.95
        }

        // Apply physics
        const velocity = new THREE.Vector3(0, 0, myState.s)
        const rotation = new THREE.Euler(myState.rx, myState.ry, myState.rz)
        velocity.applyEuler(rotation)

        myState.x += velocity.x * 0.016
        myState.y += velocity.y * 0.016
        myState.z += velocity.z * 0.016

        // Ground collision
        myState.y = Math.max(2, myState.y)

        // Apply drag
        myState.s *= drag

        if (moved || myState.s > 0.1) {
          console.log('myState', myState)
          client.updateMyData(myState)
        }
      }

      // Update other aircrafts
      function updateAircrafts() {
        const state = client.getState()
        if (!state.players) return

        for (const playerId in state.players) {
          const playerState = state.players[playerId]
          if (!aircrafts[playerId]) {
            const color = aircraftColors[parseInt(playerId) % aircraftColors.length]
            aircrafts[playerId] = createAircraft(color)
            scene.add(aircrafts[playerId])
          }

          const aircraft = aircrafts[playerId]
          aircraft.position.set(playerState.x, playerState.y, playerState.z)
          aircraft.rotation.set(playerState.rx, playerState.ry, playerState.rz)
          aircraft.userData.speed = playerState.s
        }
      }

      // Camera follow
      function updateCamera() {
        const myState = client.getMyState()
        if (!myState) return

        const position = new THREE.Vector3(myState.x, myState.y, myState.z)
        const rotation = new THREE.Euler(myState.rx, myState.ry, myState.rz)

        const offset = new THREE.Vector3(0, 15, -40)
        offset.applyEuler(rotation)

        camera.position.copy(position).add(offset)
        camera.lookAt(position)
      }

      // Handle SDK events
      client.on('connected', () => {
        console.log('connected')
        statusIndicator.className = 'status-indicator status-connected'
        statusIndicator.textContent = 'Connected'
      })

      client.on('disconnected', () => {
        console.log('disconnected')
        statusIndicator.className = 'status-indicator status-disconnected'
        statusIndicator.textContent = 'Disconnected'
      })

      client.on('id', (id) => {
        console.log('Received my ID from server:', id)

        // Create my aircraft visual representation
        const color = aircraftColors[parseInt(id) % aircraftColors.length]
        const myAircraft = createAircraft(color)
        myAircraft.position.set(0, 50, 0)
        scene.add(myAircraft)
        aircrafts[id] = myAircraft

        // Send initial state - set initial roll to match visual orientation
        const state = {
          x: 0,
          y: 50,
          z: 0,
          rx: 0,
          ry: 0,
          rz: -Math.PI / 2,
          s: 0,
        }
        client.updateMyData(state)
      })

      client.on('connect', (playerId) => {
        console.log('Client connected:', playerId)
        // No need to do anything special, they'll send their aircraft data via delta
      })

      client.on('disconnect', (playerId) => {
        console.log('Client disconnected:', playerId)
        // SDK automatically handles removing disconnected players from state
        if (aircrafts[playerId] && playerId !== client.getMyId()) {
          scene.remove(aircrafts[playerId])
          delete aircrafts[playerId]
        }
      })

      client.on('state', (state) => {
        console.log('Received initial state:', state)
        updateAircrafts()
      })

      client.on('delta', (delta) => {
        console.log('Received delta:', delta)
        updateAircrafts()
      })

      // Animation loop
      function animate() {
        requestAnimationFrame(animate)
        updateMyAircraft()
        updateAircrafts()
        updateCamera()
        updateHUD()
        renderer.render(scene, camera)
      }

      // Handle resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      })

      animate()
    </script>
  </head>
  <body>
    <div class="controls">
      <strong>Flight Controls:</strong><br />
      W/↑ - Throttle Up<br />
      S/↓ - Throttle Down<br />
      A/← - Turn Left<br />
      D/→ - Turn Right<br />
      Q - Pitch Up<br />
      E - Pitch Down
    </div>
    <div class="hud">
      ALT: 0m<br />
      SPD: 0<br />
      HDG: 0°<br />
      PITCH: 0°<br />
      ROLL: 0°
    </div>
  </body>
</html>
