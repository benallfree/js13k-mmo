<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Black Cats Demo: JS13K Online Challenge Series</title>
    <meta name="title" content="Black Cats Demo: JS13K Online Challenge Series" />
    <meta name="description" content="Black Cats Demo: JS13K Online Challenge Series" />
    <meta name="author" content="benallfree" />
    <style>
      body {
        background-color: #1a1a1a;
        font-family: 'Arial', sans-serif;
      }
      .status-indicator {
        position: fixed;
        top: 10px;
        right: 10px;
        padding: 8px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        color: white;
        transition: background-color 0.3s ease;
      }

      .status-connecting {
        background-color: #f39c12;
      }

      .status-connected {
        background-color: #27ae60;
      }

      .status-disconnected {
        background-color: #e74c3c;
      }

      .controls {
        position: fixed;
        top: 10px;
        left: 10px;
        display: flex;
        gap: 8px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .control-btn {
        padding: 8px 12px;
        border: 2px solid #444;
        border-radius: 4px;
        background: #333;
        color: white;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s ease;
      }

      .control-btn:hover {
        background: #555;
        border-color: #666;
      }

      .control-btn.active {
        background: #8b4513;
        color: white;
        border-color: #a0522d;
      }

      .game-container {
        position: fixed;
        top: 60px;
        left: 10px;
        right: 10px;
        bottom: 10px;
        background: #2d1810;
        border-radius: 8px;
        overflow: hidden;
      }

      #gameCanvas {
        display: block;
        cursor: crosshair;
      }

      .instructions {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 12px;
        border-radius: 8px;
        font-size: 14px;
        max-width: 300px;
      }

      .help-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 16px;
        border-radius: 8px;
        font-size: 14px;
        max-width: 70%;
        text-align: left;
        z-index: 5;
        display: none;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4);
      }

      .score {
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
      }
    </style>
    <script type="module">
      import Js13kClient, { generateUUID } from '/sdk/index.js'

      // Create status indicator
      const statusIndicator = document.createElement('div')
      statusIndicator.className = 'status-indicator status-connecting'
      statusIndicator.textContent = 'Connecting...'
      document.body.appendChild(statusIndicator)

      // Create score display and place in controls next to name input
      const scoreDisplay = document.createElement('div')
      scoreDisplay.className = 'score'
      scoreDisplay.textContent = 'Mice Caught: 0'
      const controlsEl = document.querySelector('.controls')
      if (controlsEl) {
        controlsEl.appendChild(scoreDisplay)
      } else {
        document.body.appendChild(scoreDisplay)
      }

      // Create client with delta evaluator
      const client = new Js13kClient('cats', {
        debug: false,
        host: window.location.origin,
        deltaNormalizer: (delta) => {
          return {
            ...delta,
            _players: Object.fromEntries(
              Object.entries(delta._players || {}).map(([playerId, player]) => {
                return [
                  playerId,
                  player == null
                    ? null
                    : {
                        ...player,
                        x: Math.round(player.x || 0),
                        y: Math.round(player.y || 0),
                      },
                ]
              })
            ),
            _mice: Object.fromEntries(
              Object.entries(delta._mice || {}).map(([mouseId, mouse]) => {
                return [
                  mouseId,
                  mouse == null
                    ? null
                    : {
                        x: Math.round(mouse.x || 0),
                        y: Math.round(mouse.y || 0),
                        owner: mouse.owner,
                      },
                ]
              })
            ),
          }
        },
        deltaEvaluator: (delta, remoteState, playerId) => {
          if (!remoteState || !playerId) {
            return true
          }

          const playerBase = remoteState._players?.[playerId]
          if (!playerBase) {
            return true
          }

          const newX = delta._players?.[playerId]?.x
          const newY = delta._players?.[playerId]?.y
          const newScore = delta._players?.[playerId]?.score
          const newName = delta._players?.[playerId]?.name

          const xChanged = newX != null && (playerBase.x == null || Math.abs(newX - playerBase.x) > 2)
          const yChanged = newY != null && (playerBase.y == null || Math.abs(newY - playerBase.y) > 2)
          const scoreChanged = newScore != null && newScore !== playerBase.score
          const nameChanged = newName != null && newName !== playerBase.name

          const mouseChanged = Object.keys(delta._mice || {}).length > 0

          // console.log(
          //   `changed`,
          //   JSON.stringify({ xChanged, yChanged, scoreChanged, nameChanged, mouseChanged }, null, 2)
          // )

          return xChanged || yChanged || scoreChanged || nameChanged || mouseChanged
        },
      })

      // Game state
      let keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
      }

      let myScore = 0

      // Canvas setup
      const canvas = document.getElementById('gameCanvas')
      const ctx = canvas.getContext('2d')

      // Help button and overlay
      const helpButton = document.createElement('button')
      helpButton.className = 'control-btn'
      helpButton.textContent = 'Help'
      helpButton.setAttribute('aria-expanded', 'false')
      const controlsEl2 = document.querySelector('.controls')
      if (controlsEl2) controlsEl2.appendChild(helpButton)

      const helpOverlay = document.createElement('div')
      helpOverlay.className = 'help-overlay'
      helpOverlay.innerHTML = `
        <div><strong>üê± Black Cats Chase MMO Mice! üê≠</strong></div>
        <div>Arrow keys to move your cat</div>
        <div>Catch the gray mice to score points</div>
        <div>Mice are shared across all players</div>
        <div>Each player gets a unique black cat</div>
        <div>Your cat label shows your name</div>
      `
      const gameContainer = document.querySelector('.game-container')
      if (gameContainer) gameContainer.appendChild(helpOverlay)

      let helpVisible = false
      function toggleHelp() {
        helpVisible = !helpVisible
        helpOverlay.style.display = helpVisible ? 'block' : 'none'
        helpButton.setAttribute('aria-expanded', String(helpVisible))
      }
      helpButton.addEventListener('click', toggleHelp)

      // Set canvas size to fill container
      function resizeCanvas() {
        const container = canvas.parentElement
        canvas.width = container.clientWidth
        canvas.height = container.clientHeight
      }

      // Initial resize
      resizeCanvas()

      // Resize on window resize
      window.addEventListener('resize', resizeCanvas)

      // Cat names for different players (not used directly; user provides name)
      const catNames = ['Shadow', 'Midnight', 'Luna', 'Raven', 'Onyx', 'Coal', 'Smokey', 'Void']

      // Draw a black cat
      function drawCat(x, y, isMyCat = false, score, name) {
        ctx.save()
        ctx.translate(x, y)

        // Cat body (black)
        ctx.fillStyle = '#000000'
        ctx.beginPath()
        ctx.ellipse(0, 0, 12, 8, 0, 0, 2 * Math.PI)
        ctx.fill()

        // Cat head
        ctx.beginPath()
        ctx.arc(0, -8, 8, 0, 2 * Math.PI)
        ctx.fill()

        // Cat ears
        ctx.beginPath()
        ctx.moveTo(-6, -14)
        ctx.lineTo(-2, -8)
        ctx.lineTo(-4, -12)
        ctx.fill()

        ctx.beginPath()
        ctx.moveTo(6, -14)
        ctx.lineTo(2, -8)
        ctx.lineTo(4, -12)
        ctx.fill()

        // Cat eyes (glowing green)
        ctx.fillStyle = '#00ff00'
        ctx.beginPath()
        ctx.arc(-3, -10, 2, 0, 2 * Math.PI)
        ctx.fill()
        ctx.beginPath()
        ctx.arc(3, -10, 2, 0, 2 * Math.PI)
        ctx.fill()

        // Cat tail
        ctx.strokeStyle = '#000000'
        ctx.lineWidth = 3
        ctx.beginPath()
        ctx.moveTo(12, 0)
        ctx.quadraticCurveTo(20, -5, 25, 0)
        ctx.stroke()

        // Label: my cat shows name (you); others show name (score)
        ctx.fillStyle = '#ff6b6b'
        ctx.font = '12px Arial'
        ctx.textAlign = 'center'
        if (isMyCat) {
          const label = name && name.trim().length > 0 ? `${name} (you)` : 'YOU'
          ctx.fillText(label, 0, -25)
        } else {
          const safeName = name && name.trim().length > 0 ? name : 'Cat'
          const safeScore = score != null ? score : 0
          ctx.fillText(`${safeName} (${safeScore})`, 0, -25)
        }

        ctx.restore()
      }

      // Draw a mouse
      function drawMouse(x, y) {
        ctx.save()
        ctx.translate(x, y)

        // Mouse body (gray)
        ctx.fillStyle = '#808080'
        ctx.beginPath()
        ctx.ellipse(0, 0, 6, 4, 0, 0, 2 * Math.PI)
        ctx.fill()

        // Mouse head
        ctx.beginPath()
        ctx.arc(0, -4, 4, 0, 2 * Math.PI)
        ctx.fill()

        // Mouse ears
        ctx.fillStyle = '#a0a0a0'
        ctx.beginPath()
        ctx.arc(-2, -6, 2, 0, 2 * Math.PI)
        ctx.fill()
        ctx.beginPath()
        ctx.arc(2, -6, 2, 0, 2 * Math.PI)
        ctx.fill()

        // Mouse eyes (red)
        ctx.fillStyle = '#ff0000'
        ctx.beginPath()
        ctx.arc(-1, -5, 1, 0, 2 * Math.PI)
        ctx.fill()
        ctx.beginPath()
        ctx.arc(1, -5, 1, 0, 2 * Math.PI)
        ctx.fill()

        // Mouse tail
        ctx.strokeStyle = '#808080'
        ctx.lineWidth = 2
        ctx.beginPath()
        ctx.moveTo(6, 0)
        ctx.lineTo(12, -2)
        ctx.stroke()

        ctx.restore()
      }

      // Generate a new mouse
      function spawnMouse() {
        const mouseId = generateUUID()
        const newMouse = {
          x: Math.random() * (canvas.width - 40) + 20,
          y: Math.random() * (canvas.height - 40) + 20,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          owner: client.getMyId(),
        }

        client.updateState({
          _mice: {
            [mouseId]: newMouse,
          },
        })
      }

      // Update mice positions (only for mice you own)
      function updateMice() {
        const state = client.getState()
        if (!state._mice) return

        Object.entries(state._mice).forEach(([mouseId, mouse]) => {
          if (mouse.owner === client.getMyId()) {
            // Update position
            mouse.x += mouse.vx
            mouse.y += mouse.vy

            // Bounce off walls
            if (mouse.x < 10 || mouse.x > canvas.width - 10) {
              mouse.vx *= -1
            }
            if (mouse.y < 10 || mouse.y > canvas.height - 10) {
              mouse.vy *= -1
            }

            // Keep mice in bounds
            mouse.x = Math.max(10, Math.min(canvas.width - 10, mouse.x))
            mouse.y = Math.max(10, Math.min(canvas.height - 10, mouse.y))

            // Send updated position
            client.updateState({
              _mice: {
                [mouseId]: mouse,
              },
            })
          }
        })
      }

      // Check collision between cat and mouse
      function checkCollision(catX, catY, mouseX, mouseY) {
        const distance = Math.sqrt((catX - mouseX) ** 2 + (catY - mouseY) ** 2)
        return distance < 20
      }

      // Render the current state to canvas
      function renderState() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height)

        // Draw spooky background
        ctx.fillStyle = '#2d1810'
        ctx.fillRect(0, 0, canvas.width, canvas.height)

        // Draw some spooky trees
        ctx.fillStyle = '#1a0f0a'
        for (let i = 0; i < 8; i++) {
          const x = (canvas.width / 8) * i
          const y = canvas.height - 30
          ctx.fillRect(x - 5, y, 10, 30)
          ctx.beginPath()
          ctx.arc(x, y - 10, 15, 0, 2 * Math.PI)
          ctx.fill()
        }

        // Draw textured moon
        const moonX = canvas.width - 50
        const moonY = 50
        const moonR = 20

        // Base gradient
        const baseGrad = ctx.createRadialGradient(
          moonX - moonR * 0.4,
          moonY - moonR * 0.4,
          moonR * 0.2,
          moonX,
          moonY,
          moonR
        )
        baseGrad.addColorStop(0, '#ffffff')
        baseGrad.addColorStop(0.55, '#f0f0f0')
        baseGrad.addColorStop(1, '#d8d8d8')

        ctx.save()
        ctx.beginPath()
        ctx.arc(moonX, moonY, moonR, 0, 2 * Math.PI)
        ctx.fillStyle = baseGrad
        ctx.fill()

        // Clip to moon and add craters
        ctx.clip()
        const craters = [
          { dx: -6, dy: -2, r: 4 },
          { dx: 3, dy: 2, r: 3 },
          { dx: -2, dy: 6, r: 2.5 },
          { dx: 6, dy: -4, r: 2 },
          { dx: 0, dy: -7, r: 1.8 },
        ]
        craters.forEach((c) => {
          // darker crater body
          ctx.globalAlpha = 0.28
          ctx.fillStyle = '#bdbdbd'
          ctx.beginPath()
          ctx.arc(moonX + c.dx, moonY + c.dy, c.r, 0, 2 * Math.PI)
          ctx.fill()

          // subtle highlight rim
          ctx.globalAlpha = 0.18
          ctx.strokeStyle = '#ffffff'
          ctx.lineWidth = 1
          ctx.beginPath()
          ctx.arc(moonX + c.dx - c.r * 0.2, moonY + c.dy - c.r * 0.2, c.r * 0.75, 0, 2 * Math.PI)
          ctx.stroke()
        })

        // Soft terminator shadow
        const shadowGrad = ctx.createRadialGradient(
          moonX + moonR * 0.5,
          moonY + moonR * 0.2,
          moonR * 0.2,
          moonX + moonR * 0.9,
          moonY + moonR * 0.5,
          moonR * 1.15
        )
        shadowGrad.addColorStop(0, 'rgba(0,0,0,0)')
        shadowGrad.addColorStop(1, 'rgba(0,0,0,0.25)')
        ctx.fillStyle = shadowGrad
        ctx.globalAlpha = 1
        ctx.beginPath()
        ctx.arc(moonX, moonY, moonR, 0, 2 * Math.PI)
        ctx.fill()
        ctx.restore()

        // Draw mice from state
        const state = client.getState()
        if (state._mice) {
          Object.values(state._mice).forEach((mouse) => {
            drawMouse(mouse.x, mouse.y)
          })
        }

        // Render all cats from state
        if (state._players) {
          for (const playerId in state._players) {
            const cat = state._players[playerId]
            const isMyCat = playerId === client.getMyId()
            drawCat(cat.x, cat.y, isMyCat, cat.score, cat.name)
          }
        }
      }

      // Update cat position based on keys
      function updateCat() {
        const myCat = client.getMyState(true)
        if (!myCat) {
          return
        }

        let moved = false

        if (keys.ArrowUp) {
          myCat.y -= 4
          moved = true
        }
        if (keys.ArrowDown) {
          myCat.y += 4
          moved = true
        }
        if (keys.ArrowLeft) {
          myCat.x -= 4
          moved = true
        }
        if (keys.ArrowRight) {
          myCat.x += 4
          moved = true
        }

        // Keep cat within bounds
        myCat.x = Math.max(20, Math.min(canvas.width - 20, myCat.x))
        myCat.y = Math.max(20, Math.min(canvas.height - 20, myCat.y))

        // Check for mouse collisions
        const state = client.getState()
        if (state._mice) {
          Object.entries(state._mice).forEach(([mouseId, mouse]) => {
            if (checkCollision(myCat.x, myCat.y, mouse.x, mouse.y)) {
              // Remove the caught mouse
              client.updateState({ _mice: { [mouseId]: null } })

              // Increase score
              myScore++
              myCat.score = myScore
              scoreDisplay.textContent = `Mice Caught: ${myScore}`
            }
          })
        }

        if (moved || myCat.score !== undefined) {
          client.updateMyState(myCat)
        }
      }

      // Handle SDK events
      client.on('open', () => {
        console.log('open')
        statusIndicator.className = 'status-indicator status-connected'
        statusIndicator.textContent = 'Connected'
      })

      client.on('close', () => {
        console.log('close')
        statusIndicator.className = 'status-indicator status-disconnected'
        statusIndicator.textContent = 'Disconnected'
      })

      client.on('id', (id) => {
        console.log('Received my ID from server:', id)

        // Initialize my cat
        const nameInputEl = document.getElementById('name-input')
        const initialCat = {
          x: canvas.width / 2,
          y: canvas.height / 2,
          score: 0,
          name: nameInputEl && 'value' in nameInputEl ? nameInputEl.value || '' : '',
        }
        console.log('Initialized my cat:', initialCat)
        client.updateMyState(initialCat)
      })

      client.on('connect', (playerId) => {
        console.log('Client connected:', playerId)
      })

      client.on('disconnect', (playerId) => {
        console.log('Client disconnected:', playerId)
      })

      client.on('state', (state) => {
        console.log('Received initial state:', JSON.stringify(state, null, 2))
      })

      client.on('delta', (delta) => {
        // console.log('Received delta:', JSON.stringify(delta, null, 2))
      })

      // Handle key events
      document.addEventListener('keydown', (event) => {
        if (keys.hasOwnProperty(event.key)) {
          keys[event.key] = true
          event.preventDefault()
        }
      })

      document.addEventListener('keyup', (event) => {
        if (keys.hasOwnProperty(event.key)) {
          keys[event.key] = false
          event.preventDefault()
        }
      })

      // Name input handling
      const nameInput = document.getElementById('name-input')
      if (nameInput) {
        nameInput.addEventListener('input', (event) => {
          const value = event.target && 'value' in event.target ? event.target.value : ''
          client.updateMyState({ name: value })
        })
      }

      // Game loop
      function gameLoop() {
        updateMice()
        updateCat()
        renderState()
        requestAnimationFrame(gameLoop)
      }

      // Spawn a new mouse after a short delay to prevent conflicts
      setInterval(() => {
        const currentState = client.getState()
        if (Object.keys(currentState._mice || {}).length < 5) {
          spawnMouse()
        }
      }, 1000)

      // Start game loop
      gameLoop()
    </script>
  </head>
  <body>
    <div class="controls">
      <input id="name-input" class="control-btn" placeholder="Enter cat name" maxlength="20" />
    </div>
    <div class="game-container">
      <canvas id="gameCanvas"></canvas>
    </div>
    <div class="instructions" style="display: none">
      <strong>üê± Black Cats Chase MMO Mice! üê≠</strong><br />
      Arrow keys to move your cat<br />
      Catch the gray mice to score points<br />
      Mice are shared across all players<br />
      Each player gets a unique black cat<br />
      Your cat label shows your name
    </div>
  </body>
</html>
